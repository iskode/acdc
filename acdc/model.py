# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/01_model.ipynb (unless otherwise specified).

__all__ = ['to_images', 'to_mri', 'MyDynamicUnet', 'unet4mri_learner']

# Cell
import fastai
from fastai import *
from fastai.vision import *
from fastai.vision import learner as ln
import sys
sys.path.append("../")
from .dataprep import *

# from fastai.data_block import *
# import nibabel as nib
# from fastai.callbacks import *
# from fastai.vision.data import SegmentationProcessor

# Cell
def to_images(mri:Tensor)->Tensor:
    return torch.cat([*mri])

def to_mri(images:Tensor, bs:int=None)->Tensor:
    assert bs != None, 'Must indicate bs'
    n_slices = images.shape[0] // bs
    return images.reshape(bs, n_slices, *images.shape[1:])

# Cell
class MyDynamicUnet(models.unet.DynamicUnet):

    def __init__(self, encoder, bs=None, **kwargs):
        assert bs != None, 'Must indicate bs'
        self.bs = bs
        super().__init__(encoder, **kwargs)

    def forward(self, x):
        x = to_images(x)
        res = super().forward(x)
        res = to_mri(res, self.bs)
        return res

def unet4mri_learner(data:DataBunch, arch:Callable, pretrained:bool=True, blur_final:bool=True,
                 norm_type:Optional[NormType]=None, split_on:Optional[SplitFuncOrIdxList]=None, blur:bool=False,
                 self_attention:bool=False, y_range:Optional[Tuple[float,float]]=None, last_cross:bool=True,
                 bottle:bool=False, cut:Union[int,Callable]=None, **learn_kwargs:Any)->Learner:
    "Build Unet learner from `data` and `arch`."
    meta = ln.cnn_config(arch)
    body = ln.create_body(arch, pretrained, cut)
    try:    size = data.train_ds[0][0].size
    except: size = next(iter(data.train_dl))[0].shape[-2:]
    model = to_device(MyDynamicUnet(body, bs=data.batch_size, n_classes=data.c, img_size=size, blur=blur, blur_final=blur_final,
          self_attention=self_attention, y_range=y_range, norm_type=norm_type, last_cross=last_cross,
          bottle=bottle), data.device)
    learn = Learner(data, model, **learn_kwargs)
    learn.split(ifnone(split_on, meta['split']))
    if pretrained: learn.freeze()
    apply_init(model[2], nn.init.kaiming_normal_)
    return learn